package away3d.tools{	import away3d.arcane;	import away3d.core.base.Geometry;	import away3d.core.base.SubGeometry;	import away3d.core.base.data.Vertex;	import away3d.core.base.data.UV;	import away3d.core.base.Object3D;	import away3d.loading.IResource;	import away3d.loading.ResourceDependency;	import away3d.entities.Mesh;	import away3d.entities.Entity;	import away3d.containers.ObjectContainer3D;	import away3d.materials.MaterialBase;	import away3d.tools.utils.Bounds;	 	import flash.geom.Vector3D;	import flash.geom.Matrix3D;		use namespace arcane;		/**	* Helper Class for the Mesh object <code>MeshHelper</code>	* A series of methods usually usefull for mesh manipulations	*/	 	public class MeshHelper {				private static const LIMIT:uint = 64998;		/**		* Returns the boundingRadius of an Entity of a Mesh.		* @param mesh		Mesh. The mesh to get the boundingRadius from.		*/		public static function boundingRadius(mesh:Mesh):Number		{			var radius:Number;			try{				radius = Math.max((mesh.maxX-mesh.minX)*Object3D(mesh).scaleX, (mesh.maxY-mesh.minY)*Object3D(mesh).scaleY, (mesh.maxZ-mesh.minZ)*Object3D(mesh).scaleZ);			}catch(e:Error){			 	Bounds.getMeshBounds(mesh);				radius = Math.max((Bounds.maxX-Bounds.minX)*Object3D(mesh).scaleX, (Bounds.maxY-Bounds.minY)*Object3D(mesh).scaleY, (Bounds.maxZ-Bounds.minZ)*Object3D(mesh).scaleZ);			}						return radius *.5;		}				/**		* Returns the boundingRadius of a ObjectContainer3D		* @param container		ObjectContainer3D. The ObjectContainer3D and its children to get the boundingRadius from.		*/		public static function boundingRadiusContainer(container:ObjectContainer3D):Number		{			Bounds.getObjectContainerBounds(container);			var radius:Number = Math.max((Bounds.maxX-Bounds.minX)*Object3D(container).scaleX, (Bounds.maxY-Bounds.minY)*Object3D(container).scaleY, (Bounds.maxZ-Bounds.minZ)*Object3D(container).scaleZ);			return radius *.5;		}		 		/**		* Recenter geometry, (its pivot is at center of geometry)		* @param mesh				Mesh. The Mesh to offset		*/		public static function recenter(mesh:Mesh):void		{			applyPosition(mesh, (mesh.minX+mesh.maxX)*.5, (mesh.minY+mesh.maxY)*.5, (mesh.minZ+mesh.maxZ)*.5);		}				/**		* Applys the rotation values of a mesh in object space and resets rotations to zero.		* @param mesh				Mesh. The Mesh to alter		*/		public static function applyRotations(mesh:Mesh):void		{			var geometry:Geometry = mesh.geometry;			var geometries:Vector.<SubGeometry> = geometry.subGeometries;			var numSubGeoms:int = geometries.length;			var vertices:Vector.<Number>;			var verticesLength: uint;			var j: uint;						var t:Matrix3D = mesh.transform;			var _holder:Vector3D = new Vector3D();			var yind:uint;			var zind:uint;			var subGeom:SubGeometry;			for (var i :uint = 0; i<numSubGeoms; ++i){					subGeom = SubGeometry(geometries[i]);					vertices = subGeom.vertexData;					verticesLength = vertices.length;					 					for (j = 0; j<verticesLength; j+=3){						_holder.x = vertices[j];						_holder.y = vertices[yind = j+1];						_holder.z = vertices[zind = j+2];						_holder = t.deltaTransformVector(_holder);						vertices[j] = _holder.x;						vertices[yind] = _holder.y;						vertices[zind] = _holder.z;					}										subGeom.updateVertexData(vertices);			}			mesh.rotationX = mesh.rotationY = mesh.rotationZ = 0; 		}				/**		* Applys an offset to a mesh at vertices level		* @param mesh				Mesh. The Mesh to offset		* @param dx					Number. The offset along the x axis		* @param dy					Number. The offset along the y axis		* @param dz					Number. The offset along the z axis		*/		public static function applyPosition(mesh:Mesh, dx:Number, dy:Number, dz:Number):void		{			var geometry:Geometry = mesh.geometry;			var geometries:Vector.<SubGeometry> = geometry.subGeometries;			var numSubGeoms:int = geometries.length;			var vertices:Vector.<Number>;			var verticesLength: uint;			var j: uint;			var subGeom:SubGeometry;			for (var i :uint = 0; i<numSubGeoms; ++i){					subGeom = SubGeometry(geometries[i]);					vertices = subGeom.vertexData;					verticesLength = vertices.length;					 					for (j = 0; j<verticesLength; j+=3){						vertices[j] -= dx;						vertices[j+1] -= dy;						vertices[j+2] -= dz;					}										subGeom.updateVertexData(vertices);			}		}				/**		* Duplicates a Mesh		* @param mesh				Mesh. The mesh to duplicate		* @param newname		[optional] String. new name for the duplicated mesh. Default = "";		*/		public static function duplicate(mesh:Mesh, newName:String = ""):Mesh		{			var geometry:Geometry = mesh.geometry.clone();			var newMesh:Mesh = new Mesh(mesh.material, geometry);			newMesh.name = newName;						return newMesh;		}				/**		* Inverts the faces of all the Meshes into an ObjectContainer3D		* @param obj		ObjectContainer3D. The ObjectContainer3D to invert.		*/		public static function invertContainerFaces(obj:ObjectContainer3D):void		{			var child:ObjectContainer3D;								if(obj is Mesh && ObjectContainer3D(obj).numChildren == 0)					invertFaces(Mesh(obj));					 				for(var i:uint = 0;i<ObjectContainer3D(obj).numChildren;++i){					child = ObjectContainer3D(obj).getChildAt(i);					invertContainerFaces(child);				}					}				/**		* Inverts the faces of a Mesh		* @param mesh		Mesh. The Mesh to invert.		*/		public static function invertFaces(mesh:Mesh):void		{			var subGeometries:Vector.<SubGeometry> = mesh.geometry.subGeometries;			var numSubGeoms:uint = subGeometries.length;			var sourceverts:Vector.<Number>;			var indices:Vector.<uint>;			var uvs:Vector.<Number>;						var i:uint;			var j:uint;			var indV0:uint;			var indV1:uint;			var indUV0:uint;			var indUV1:uint;						var v0:Vertex = new Vertex();			var v1:Vertex = new Vertex();						var uv0:UV = new UV();			var uv1:UV = new UV();						var subGeom:SubGeometry;						for (i = 0; i<numSubGeoms; ++i){				subGeom = SubGeometry(subGeometries[i]);				sourceverts = subGeom.vertexData;				indices = subGeom.indexData;				uvs = subGeom.UVData;								for (j = 0; j<indices.length; j+=3){					indV0 = indices[j]*3;					indV1 = indices[j+1]*3;					indUV0 = indices[j]*2;					indUV1 = indices[j+1]*2;					v0.x = sourceverts[indV0];					v0.y = sourceverts[indV0+1];					v0.z = sourceverts[indV0+2];										uv0.u = uvs[indUV0];					uv0.v = uvs[indUV0+1];					 					v1.x = sourceverts[indV1];					v1.y = sourceverts[indV1+1];					v1.z = sourceverts[indV1+2];										uv1.u = uvs[indUV1];					uv1.v = uvs[indUV1+1];										sourceverts[indV0] = v1.x;					sourceverts[indV0+1] = v1.y;					sourceverts[indV0+2] = v1.z;										sourceverts[indV1] = v0.x;					sourceverts[indV1+1] = v0.y;					sourceverts[indV1+2] = v0.z;					 					uvs[indUV0] = uv1.u;					uvs[indUV0+1] = uv1.v;										uvs[indUV1] = uv0.u;					uvs[indUV1+1] = uv0.v;										subGeom.updateVertexData(sourceverts);					subGeom.updateUVData(uvs);					 				}			}		}				/**		* Build a Mesh from Vectors		* @param vertices					Vector.<Number>, the vertices Vector		* @param indices					Vector.<uint>, the indices Vector		* @param uvs						Vector.<Number>, the uvs Vector		* @param name				[optional] String. new name for the gnerated mesh. Default = "";		* @param material			[optional] MaterialBase. new name for the duplicated mesh. Default = null;		*/		public static function build(vertices:Vector.<Number>, indices:Vector.<uint>, uvs:Vector.<Number>, name:String = "", material:MaterialBase = null):Mesh		{			var sub_geom:SubGeometry;			var geometry:Geometry = new Geometry();			var m:Mesh = new Mesh(material, geometry);			 			if(name != "")				m.name = name;			if(vertices.length<LIMIT){				sub_geom = new SubGeometry();				sub_geom.updateVertexData(vertices);				sub_geom.updateIndexData(indices);				sub_geom.updateUVData(uvs);				geometry.addSubGeometry(sub_geom);								return m;							} else {								var nvertices:Vector.<Number> = new Vector.<Number>();				var nindices:Vector.<uint> = new Vector.<uint>();				var nuvs:Vector.<Number> = new Vector.<Number>();				var submeshes:Array = [nvertices, nindices, nuvs];								var index:uint;				var induv:uint;				var ind:uint;				var nind:uint;				var ninduv:uint;								var i:uint;				var j:uint;								for (i = 0;i<vertices.length;i+=3){										if(index >= LIMIT ){						index = 0;						nind = 0;						nvertices = new Vector.<Number>();						nindices = new Vector.<uint>();						nuvs = new Vector.<Number>();						submeshes.push(nvertices,nindices,nuvs);					}										nvertices[index++] = vertices[i];					nvertices[index++] = vertices[i+1];					nvertices[index++] = vertices[i+2];										nindices[nind] = indices[ind];										nuvs[ninduv++] = uvs[induv++];					nuvs[ninduv++] = uvs[induv++];					 					ind++;					nind++;					induv++;				}				 				for(i=0;i<submeshes.length;i+=3){					sub_geom = new SubGeometry();					sub_geom.updateVertexData(submeshes[i]);					sub_geom.updateIndexData(submeshes[i+1]);					sub_geom.updateUVData(submeshes[i+2]);					geometry.addSubGeometry(sub_geom);				}							}						return m;		}				/**		* unfinished: to do unique material checks, empty subgemometries & animation		* Returns a mesh with its subgeometries reorganized 		*/		public static function compactData(m:Mesh) : Mesh		{			var geometries:Vector.<SubGeometry> = m.geometry.subGeometries;			var numSubGeoms:int = geometries.length;						var vertices:Vector.<Number> = new Vector.<Number>();			var indices:Vector.<uint> = new Vector.<uint>();			var uvs:Vector.<Number> =new Vector.<Number>();						var subGeom:SubGeometry;			var index:uint;			var indexuv:uint;			var indexind:uint;			var offset:uint;						var subvertices:Vector.<Number>;			var subindices:Vector.<uint>;			var subuvs:Vector.<Number>;						var j : uint;			var vecLength : uint;						for (var i : uint = 0; i < numSubGeoms; ++i){				subGeom = geometries[i];				subvertices = subGeom.vertexData;				vecLength = subvertices.length;				for (j = 0; j < vecLength; ++j){					vertices[index++] = subvertices[j];				}								subindices = subGeom.indexData;				vecLength = subindices.length;				for (j = 0; j < vecLength; ++j){					indices[indexind++] = subindices[j]+offset;				}				offset +=vecLength;								subuvs = subGeom.UVData;				vecLength = subuvs.length;				for (j = 0; j < vecLength; ++j){					uvs[indexuv++] = subuvs[j];				}			}						return build(vertices, indices, uvs, m.name, m.material);		}	}}