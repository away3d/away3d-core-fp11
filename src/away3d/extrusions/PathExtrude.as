package away3d.extrusions{		import away3d.core.base.data.UV;	import away3d.core.base.data.Vertex;	import away3d.core.base.Geometry;	import away3d.core.base.SubGeometry;	import away3d.core.base.SubMesh;	import away3d.materials.MaterialBase;	import away3d.materials.BitmapMaterial;	import away3d.loading.parsers.data.DefaultBitmapData;	import away3d.materials.utils.MultipleMaterials;	import away3d.bounds.BoundingVolumeBase;	import away3d.entities.Mesh;	import away3d.tools.MeshHelper;	import away3d.extrusions.utils.Path;	import away3d.extrusions.utils.PathUtils;	 	import flash.geom.Vector3D;	import flash.geom.Matrix3D;		public class PathExtrude extends Mesh	{		private var _varr:Vector.<Vertex>;		private var _doubles:Vector.<Vertex> = new Vector.<Vertex>();		private var _xAxis:Vector3D = new Vector3D(0.0, 0.0, 0.0);    	private var _yAxis:Vector3D = new Vector3D(0.0, 0.0, 0.0);    	private var _zAxis:Vector3D = new Vector3D(0.0, 0.0, 0.0);		private var _worldAxis:Vector3D = new Vector3D(0,1,0);		private var _trans:Matrix3D = new Matrix3D();				private const LIMIT:uint = 64998;		private var _path:Path;		private var _profile:Vector.<Vector3D>;		private var _centerMesh:Boolean;		private var _scales:Vector.<Vector3D>;		private var _rotations:Vector.<Vector3D>;		private var _materials:Vector.<MaterialBase>;		private var _activeMaterial:MaterialBase;		private var _subdivision:uint;		private var _coverAll:Boolean = true;		private var _coverSegment:Boolean = false;		private var _flip:Boolean = false;		private var _mapfit:Boolean;		private var _closePath:Boolean = false;		private var _alignToPath:Boolean = true;		private var _smoothScale:Boolean = true;		private var _isClosedProfile:Boolean = false;				private var _matIndex:uint = 0;		private var _segIndex:uint = 0;		private var _segvstart:uint = 0;		private var _segv:uint;		 		private var _geomDirty : Boolean = true;		private var _subGeometry:SubGeometry;		private var _MaterialsSubGeometries:Vector.<SubGeometryList> = new Vector.<SubGeometryList>();		private var _uva:UV;		private var _uvb:UV;		private var _uvc:UV;		private var _uvd:UV;		private var _uvs : Vector.<Number>;		private var _vertices : Vector.<Number>;		private var _indices : Vector.<uint>;				/**		* Creates a new <code>PathExtrude</code>		*		*@param	material			[optional] 	MaterialBase. The LatheExtrude (Mesh) material. Optional in constructor, material must be set before LatheExtrude object is render.		* @param	path				[optional]	Path. Defines the <code>Path</code> object representing path to extrude along. Required for the class.		* @param	profile			[optional]	Vector.<Vector3D>. Defines an Vector.<Vector3D> of Vector3D objects representing the profile information to be projected along the Path object.		* @param	subdivision		[optional]	uint. Howmany steps between each PathSegment. If the path holds curves, the higher this value, the higher the curve fidelity. 		* @param	coverall			[optional] 	Boolean. Defines the uv mapping, when true a unique material is stretched along the entire path/shape. Default is true.		* @param	coverSegment[optional] 	Boolean. Defines the uv mapping, when true and coverall is false a unique material is stretched along one PathSegment. Default is false.		* @param	alignToPath	[optional]	Boolean. If the profile must follow the path or keep its original orientation.		* @param	centerMesh	[optional] 	Boolean. If the geometry needs to be recentered in its own object space. If the position after generation is set to 0,0,0, the object would be centered in worldspace. Default is false.		* @param	mapfit			[optional]	Boolean. The UV mapping is percentually spreaded over the width of the path, making texture looking nicer and edits for applications such as a race track, road, more easy.		* @param	flip				[optional]	Boolean. If the faces must be reversed depending on Vector3D's orientation. Default is false.		* @param	closePath		[optional]	Boolean. If the last PathSegment entered must be welded back to first one. Executed in a straight manner, its recommanded to pass the first entry to the Path again, as last entry if curves are involved.		* @param	materials		[optional]	Vector.<MaterialBase>. An optional Vector.<MaterialBase> of different materials that can be alternated along the path if coverAll is false.		* @param	scales			[optional]	An optional Vector.<Vector3D> of <code>Vector3D</code> objects that defines a series of scales to be set on each PathSegment.		* @param	smoothScale	[optional]	Boolean. Defines if the scale must be interpolated between values or keep their full aspect on each PathSegment.		* @param	rotations		[optional]	An optional Vector.<Vector3D> of <code>Vector3D</code> objects that defines a series of rotations to be set on each PathSegment.		*		*/		function PathExtrude(	material:MaterialBase = null, path:Path = null, profile:Vector.<Vector3D> = null, subdivision:uint = 1, coverAll:Boolean = true, coverSegment:Boolean = false, alignToPath:Boolean = true, centerMesh:Boolean = false, mapfit:Boolean = false, flip:Boolean = false, closePath:Boolean = false,							 			materials:Vector.<MaterialBase> = null, scales:Vector.<Vector3D> = null, smoothScale:Boolean = true, rotations:Vector.<Vector3D> = null)		{			var geom : Geometry = new Geometry();			_subGeometry = new SubGeometry();			super((!material)? new BitmapMaterial(DefaultBitmapData.bitmapData) : material, geom);						_activeMaterial = this.material;			_path = path;			_profile = profile;			this.subdivision = subdivision;			_coverSegment = coverSegment;			_coverAll = (_coverSegment)? false : coverAll;			_alignToPath = alignToPath;			_centerMesh = centerMesh;			_mapfit = mapfit;			_flip = flip;			_closePath = closePath;			_materials = (materials)?materials : new Vector.<MaterialBase>();			_scales = scales;			_smoothScale = smoothScale;			_rotations = rotations;		}				/**		 * @inheritDoc		 */		override public function get bounds() : BoundingVolumeBase		{			if (_geomDirty) 				buildExtrude();						return super.bounds;		}		/**		 * @inheritDoc		 */		override public function get geometry() : Geometry		{			if (_geomDirty) buildExtrude();			 			return super.geometry;		}		/**		 * @inheritDoc		 */		override public function get subMeshes():Vector.<SubMesh>		{			if (_geomDirty) buildExtrude();			 			return super.subMeshes;		}				/**    	 * Defines whether the mesh is recentered of not after generation    	 */    	public function get centerMesh():Boolean    	{    		return _centerMesh;    	}    	    	public function set centerMesh(val:Boolean):void    	{    		if (_centerMesh == val)    			return;    		    		_centerMesh = val;						if (_centerMesh && _subGeometry.vertexData.length > 0){				MeshHelper.recenter( this);			}else{				invalidateGeometry();			}    	}				/**		 * Invalidates the geometry, causing it to be rebuillded when requested.		 */		private function invalidateGeometry() : void		{			_geomDirty = true;			invalidateBounds();		}				 /**    	 * Defines the <code>Path</code> object representing path to extrude along. Required.    	 */ 		public function get path():Path    	{    		return _path;    	}				public function set path(val:Path):void    	{    		_path = val;    		_geomDirty = true;    	}    			/**    	 * Defines a Vector.<Vector3D> of Vector3D objects representing the profile information to be projected along the Path object. Required.    	 */		public function get profile():Vector.<Vector3D>    	{    		return _profile;    	}				public function set profile(val:Vector.<Vector3D>):void    	{    		_profile = val;    		    		if (_profile != null)				_isClosedProfile = (_profile[0].x == _profile[_profile.length-1].x && _profile[0].y == _profile[_profile.length-1].y && _profile[0].z == _profile[_profile.length-1].z);						_geomDirty = true;    	}    			/**    	 * An optional Vector.<Vector3D> of <code>Vector3D</code> objects that defines a series of scales to be set on each PathSegment.    	 */		public function get scales():Vector.<Vector3D>    	{    		return _scales;    	}    			public function set scales(val:Vector.<Vector3D>):void    	{    		_scales = val;    		_geomDirty = true;    	}				/**    	 * An optional Vector.<Vector3D> of <code>Vector3D</code> objects that defines a series of rotations to be set on each PathSegment.    	 */		public function get rotations():Vector.<Vector3D>    	{    		return _rotations;    	}    			public function set rotations(val:Vector.<Vector3D>):void    	{    		_rotations = val;    		_geomDirty = true;    	}				/**		 * An optional Vector.<MaterialBase>. It defines a series of materials to be set on each PathSegment if coverAll is set to false.    	 */		public function get materials():Vector.<MaterialBase>    	{    		return _materials;    	}    			public function set materials(val:Vector.<MaterialBase>):void    	{    		_materials = val;    		_geomDirty = true;    	}				 		/**    	 * Defines the subdivisions created in the mesh for each PathSegment. Defaults to 2, minimum 2.    	 */ 		public function get subdivision():int		{			return _subdivision;		}				public function set subdivision(val:int):void		{			val = (val<1)? 1 : val;						if (_subdivision == val)				return;						_subdivision = val;			_geomDirty = true;		}				/**    	 * Defines if the texture(s) should be stretched to cover the entire mesh or per step between segments. Defaults to true.    	 */		public function get coverAll():Boolean		{			return _coverAll;		}				public function set coverAll(val:Boolean):void		{			if (_coverAll == val)				return;						_coverAll = val;			_geomDirty = true;		}				/**    	 * Defines if the texture(s) should applied per segment. Default false.    	 */		public function set coverSegment(b:Boolean):void		{			_coverSegment = b;		}		public function get coverSegment():Boolean		{			return _coverSegment;		}				/**    	 * Defines if the texture(s) should be projected on the geometry evenly spreaded over the source bitmapdata or using distance/percent. Default is false.		 * Note that it is NOT suitable if a scale array is being used. The mapping considers first and last profile points are the most distant from each other. most left and most right on the map.    	 */		public function get mapfit():Boolean		{			return _mapfit;		}				public function set mapfit(val:Boolean):void		{			if (_mapfit == val)				return;						_mapfit = val;			_geomDirty = true;		}				/**    	 * Defines if the generated faces should be inversed. Default false.    	 */		public function get flip():Boolean		{			return _flip;		}				public function set flip(val:Boolean):void		{			if (_flip == val)				return;						_flip = val;			_geomDirty = true;		}				/**    	 * Defines if the last PathSegment should join the first one and close the loop. Defaults to false.    	 */		public function get closePath():Boolean		{			return _closePath;		}				public function set closePath(val:Boolean):void		{			if (_closePath == val)				return;						_closePath = val;			_geomDirty = true;		}				/**    	 * Defines if the array of profile points should be orientated on path or not. Default true. Note that Path object's worldaxis property might need to be changed. default = 0,1,0.    	 *     	 * @see #profile    	 */		public function get aligntoPath():Boolean		{			return _alignToPath;		}				public function set alignToPath(val:Boolean):void		{			if (_alignToPath == val)				return;						_alignToPath = val;			_geomDirty = true;		}				/**    	 * Defines if a scaling of a PathSegment defined from the scales array of <code>Vector3D</code> objects should affect the whole PathSegment evenly or be smoothly interpolated from previous PathSegment scale. Defaults to true.    	 *     	 * @see #scales    	 */		public function get smoothScale():Boolean		{			return _smoothScale;		}				public function set smoothScale(val:Boolean):void		{			if (_smoothScale == val)				return;						_smoothScale = val;			_geomDirty = true;		}		        private function orientateAt(target:Vector3D, position:Vector3D):void        {            _zAxis = target.subtract(position);            _zAxis.normalize();                if (_zAxis.length > 0.1)            {                _xAxis = _worldAxis.crossProduct(_zAxis);                _xAxis.normalize();                    _yAxis = _xAxis.crossProduct(_zAxis);                _yAxis.normalize();    			    			var rawData:Vector.<Number> = _trans.rawData;    			                rawData[0] = _xAxis.x;                rawData[1] = _xAxis.y;                rawData[2] = _xAxis.z;                    rawData[4] = -_yAxis.x;                rawData[5] = -_yAxis.y;                rawData[6] = -_yAxis.z;                    rawData[8] = _zAxis.x;                rawData[9] = _zAxis.y;                rawData[10] = _zAxis.z;								_trans.rawData = rawData;            }        }				private function generate(points:Vector.<Vector.<Vector3D>>, offsetV:int = 0, closedata:Boolean = false):void		{			if (_materials.length)				_matIndex = _materials.length;						var uvlength:int = (points.length-1) + offsetV;						for(var i:int = 0;i< points.length-1;++i){				_varr = new Vector.<Vertex>();				extrudePoints( points[i], points[i+1], (1/uvlength)*((closedata)? i+(uvlength-1) : i), uvlength, ((closedata)? i+(uvlength-1) : i)/_subdivision);								if(i ==0 && _isClosedProfile){					_doubles = _varr.concat();				}			}			_varr = _doubles = null;		}				private function extrudePoints(points1:Vector.<Vector3D>, points2:Vector.<Vector3D>, vscale:Number, indexv:int, indexp:int):void		{			var i:int;			var j:int;						var stepx:Number;			var stepy:Number;			var stepz:Number;			 			var va:Vertex;			var vb:Vertex;			var vc:Vertex;			var vd:Vertex;						var u1:Number;			var u2:Number;			var index:uint = 0;						var v1:Number = 0;			var v2:Number = 0;						var countloop:int = points1.length;						var mat:MaterialBase;						if(_mapfit){				var dist:Number = 0;				var tdist:Number;				var bleft:Vector3D;				for(i = 0;i<countloop; ++i){					for(j = 0;j< countloop; ++j){						if(i != j){							tdist = Vector3D.distance(points1[i], points1[j]);							if(tdist>dist){								dist = tdist;								bleft = points1[i];							}						}					}				}							} else {				var bu:Number = 0;				var bincu:Number = 1/(countloop-1);			}						function getDouble(x:Number, y:Number, z:Number ):Vertex			{				for(var i:int = 0;i<_doubles.length; ++i){					if( _doubles[i].x == x && _doubles[i].y == y && _doubles[i].z == z){						return _doubles[i];					}				}				return new Vertex( x, y, z); 			}			 			for( i = 0; i < countloop; ++i){				stepx = points2[i].x - points1[i].x;				stepy = points2[i].y - points1[i].y;				stepz = points2[i].z - points1[i].z;								for( j = 0; j < 2; ++j){					if(_isClosedProfile &&  _doubles.length > 0){						_varr.push( getDouble(points1[i].x+(stepx*j) , points1[i].y+(stepy*j), points1[i].z+(stepz*j) )   );					} else {						_varr.push( new Vertex( points1[i].x+(stepx*j) , points1[i].y+(stepy*j), points1[i].z+(stepz*j)) );					}				}			}						if(_coverSegment){								if(indexp>_segIndex){					_segIndex = indexp;					_segvstart = 0;					_segv = 1/(_subdivision);										if(_materials.length) _matIndex = (_matIndex+1 > _materials.length-1)? 0 : _matIndex+1;				}							} else{								if(_materials.length && !_coverAll) _matIndex = (_matIndex+1 > _materials.length-1)? 0 : _matIndex+1;			}			mat = (_materials || _coverAll)? this.material : _materials[_matIndex] ;						for( i = 0; i < countloop-1; ++i){								if(_mapfit){					u1 = Vector3D.distance(points1[i], bleft) /dist;					u2 = Vector3D.distance(points1[i+1], bleft) /dist;									} else {					u1 = bu;					bu += bincu;					u2 = bu;				}				 				v1 = (_coverAll)? vscale : ( (_coverSegment)? _segvstart : 0 );				v2 = (_coverAll)? vscale+(1/indexv) : ( (_coverSegment)? (_segvstart+ _segv) : 1 );				 				_uva.u = u1;				_uva.v = v1;				_uvb.u = u1;				_uvb.v = v2;				_uvc.u = u2;				_uvc.v = v2;				_uvd.u = u2;				_uvd.v = v1;				va = _varr[index];				vb = _varr[index+ 1];				vc = _varr[index+3];				vd = _varr[index+2];				 				if(flip){					addFace(vb, va, vc, _uvb, _uva, _uvc, mat);					addFace(vc, va, vd, _uvc, _uva, _uvd, mat);									} else {					addFace(va, vb, vc, _uva, _uvb, _uvc, mat);					addFace(va, vc, vd, _uva, _uvc, _uvd, mat);				}				  				if(_mapfit) u1 = u2;				 				index += 2;			}						if(_coverSegment) _segvstart += _segv;						 		}				private function initHolders():void		{				_uva = new UV(0,0);			_uvb = new UV(0,0);			_uvc = new UV(0,0);			_uvd = new UV(0,0);						_uvs = new Vector.<Number>();			_vertices = new Vector.<Number>();			_indices = new Vector.<uint>();			 			_subGeometry.autoDeriveVertexNormals = true;            _subGeometry.autoDeriveVertexTangents = true;						if(_materials && _materials.length > 0){				var sglist:SubGeometryList = new SubGeometryList();				_MaterialsSubGeometries.push(sglist);				sglist.subGeometry = _subGeometry;				sglist.uvs = _uvs;				sglist.vertices = _vertices;				sglist.indices = _indices;				sglist.material = this.material; 			}		}				private function getSubGeometryListFromMaterial(mat:MaterialBase):SubGeometryList		{			var sglist:SubGeometryList;						for(var i:uint = 0;i<_MaterialsSubGeometries.length;++i)				if(_MaterialsSubGeometries[i].material == mat) sglist = _MaterialsSubGeometries[i];						if(!sglist){				sglist = new SubGeometryList();				_MaterialsSubGeometries.push(sglist);				sglist.subGeometry = _subGeometry;				sglist.uvs = new Vector.<Number>();				sglist.vertices = new Vector.<Number>();				sglist.indices = new Vector.<uint>();				sglist.material = mat;			}						return sglist;		}				private function addFace(v0:Vertex, v1:Vertex, v2:Vertex, uv0:UV, uv1:UV, uv2:UV, mat:MaterialBase):void		{			var subGeom:SubGeometry;			var uvs:Vector.<Number>;			var vertices:Vector.<Number>;			var indices:Vector.<uint>;			var sglist:SubGeometryList;						if(_activeMaterial != mat && _materials && _materials.length > 0){				_activeMaterial = mat;				sglist = getSubGeometryListFromMaterial(mat);				_subGeometry = subGeom = sglist.subGeometry;				_uvs = uvs = sglist.uvs;				_vertices = vertices = sglist.vertices;				_indices = sglist.indices;							} else {							 	subGeom = _subGeometry;				uvs = _uvs;				vertices = _vertices;				indices = _indices;			}					if(vertices.length+9>LIMIT){				subGeom.updateVertexData(vertices);				subGeom.updateIndexData(indices);				subGeom.updateUVData(uvs);				this.geometry.addSubGeometry(subGeom);				this.subMeshes[this.subMeshes.length-1].material = mat;				 				subGeom = new SubGeometry();				subGeom.autoDeriveVertexNormals = true;				subGeom.autoDeriveVertexTangents = true;				if(_MaterialsSubGeometries && _MaterialsSubGeometries.length > 1){					sglist = getSubGeometryListFromMaterial(mat);					sglist.subGeometry = _subGeometry = subGeom;					sglist.uvs = _uvs = uvs = new Vector.<Number>();					sglist.vertices = _vertices = vertices = new Vector.<Number>();					sglist.indices =_indices = indices = new Vector.<uint>();					 				} else {										_subGeometry = subGeom;					uvs = _uvs = new Vector.<Number>();					vertices = _vertices = new Vector.<Number>();					indices = _indices = new Vector.<uint>();				}			} 			 			var bv0:Boolean;			var bv1:Boolean;			var bv2:Boolean;						var ind0:uint;			var ind1:uint;			var ind2:uint;						var uvind:uint;			var vind:uint;			var ind:uint;						var indlength:uint = indices.length;			 			if(indlength>_profile.length*2){				var limitBack:uint = indlength-3-_profile.length;				for(var i:uint = indlength-3; i> limitBack;i-=3){					ind = indices[i];					uvind = ind*2;					vind = ind*3;					 					if(!bv0 && vertices[vind] == v0.x){						if(vertices[vind+1] == v0.y && vertices[vind+2] == v0.z){							ind0 = ind;							bv0 = true;							continue;						}					}										if(!bv1 && vertices[vind] == v1.x){						if(vertices[vind+1] == v1.y && vertices[vind+2] == v1.z){							ind1 = ind;							bv1 = true;							continue;						}					}										if(!bv2 && vertices[vind] == v2.x){						if(vertices[vind+1] == v2.y && vertices[vind+2] == v2.z){							ind2 = ind;							bv2 = true;							continue;						}					}										if(bv0 && bv1 && bv2)						break;				}			}						if(!bv0){				ind0 = vertices.length/3;				vertices.push(v0.x, v0.y, v0.z);				uvs.push(uv0.u, uv0.v);			}						if(!bv1){				ind1 = vertices.length/3;				vertices.push(v1.x, v1.y, v1.z);				uvs.push(uv1.u, uv1.v);			}						if(!bv2){				ind2 = vertices.length/3;				vertices.push(v2.x, v2.y, v2.z);				uvs.push(uv2.u, uv2.v);			}						indices.push(ind0, ind1, ind2);		}		    	private function buildExtrude():void    	{    		 			if(_path == null || _path.length == 0 || _profile == null || _profile.length < 2)				throw new Error("PathExtrude error: invalid Path or profile with unsufficient data");								_geomDirty = false;				initHolders();								_worldAxis = _path.worldAxis;								var vSegPts:Vector.<Vector.<Vector3D>> = PathUtils.getPointsOnCurve(_path, _subdivision);				var vPtsList:Vector.<Vector3D> = new Vector.<Vector3D>();				var vSegResults:Vector.<Vector.<Vector3D>> = new Vector.<Vector.<Vector3D>>();				var atmp:Vector.<Vector3D>;				var tmppt:Vector3D = new Vector3D(0,0,0);				 				var i:uint;				var j:uint;				var k:uint;								var nextpt:Vector3D;								if(_closePath) var lastP:Vector.<Vector3D> = new Vector.<Vector3D>();								var rescale:Boolean = (_scales != null);				if(rescale) var lastscale:Vector3D = (_scales[0] == null)? new Vector3D(1, 1, 1) : _scales[0];									var rotate:Boolean = (_rotations != null);								if(rotate && _rotations.length > 0){					var lastrotate:Vector3D = _rotations[0] ;					var nextrotate:Vector3D;					var rotation:Vector.<Vector3D> = new Vector.<Vector3D>();					var tweenrot:Vector3D;				}				 				if(_smoothScale && rescale){					var nextscale:Vector3D = new Vector3D(1, 1, 1);					var vScales:Vector.<Vector3D> = Vector.<Vector3D>([lastscale]);				}								var tmploop:int = _profile.length;				for (i = 0; i <vSegPts.length; ++i) {					if(rotate){						lastrotate = (_rotations[i] == null) ? lastrotate : _rotations[i];						nextrotate = (_rotations[i+1] == null) ? lastrotate : _rotations[i+1];						rotation = Vector.<Vector3D>([lastrotate]);						rotation = rotation.concat(PathUtils.step( lastrotate, nextrotate,  _subdivision));					}										if(rescale)  lastscale = (_scales[i] == null)? lastscale : _scales[i];					 					if(_smoothScale && rescale ){						nextscale = (_scales[i+1] == null) ? (_scales[i] == null)? lastscale : _scales[i] : _scales[i+1];						vScales = vScales.concat(PathUtils.step( lastscale, nextscale, _subdivision));					}										for(j = 0; j<vSegPts[i].length;++j){						 						atmp = new Vector.<Vector3D>();						atmp = atmp.concat(_profile);						vPtsList = new Vector.<Vector3D>();												if(rotate)							tweenrot = rotation[j];						if(_alignToPath) {							_trans = new Matrix3D();							if(i == vSegPts.length -1 && j==vSegPts[i].length-1){																if(_closePath){									nextpt = vSegPts[0][0];									orientateAt(nextpt, vSegPts[i][j]);								} else{									nextpt = vSegPts[i][j-1];									orientateAt(vSegPts[i][j], nextpt);								}															} else {								nextpt = (j<vSegPts[i].length-1)? vSegPts[i][j+1]:  vSegPts[i+1][0];								orientateAt(nextpt, vSegPts[i][j]);							}						}												for (k = 0; k <tmploop; ++k) {													if(_alignToPath) {								tmppt = new Vector3D();								tmppt.x = atmp[k].x * _trans.rawData[0] + atmp[k].y * _trans.rawData[4] + atmp[k].z * _trans.rawData[8] + _trans.rawData[12];								tmppt.y = atmp[k].x * _trans.rawData[1] + atmp[k].y * _trans.rawData[5] + atmp[k].z * _trans.rawData[9] + _trans.rawData[13];								tmppt.z = atmp[k].x * _trans.rawData[2] + atmp[k].y * _trans.rawData[6] + atmp[k].z * _trans.rawData[10] + _trans.rawData[14];																if(rotate)									tmppt = PathUtils.rotatePoint(tmppt, tweenrot);								 								tmppt.x +=  vSegPts[i][j].x;								tmppt.y +=  vSegPts[i][j].y;								tmppt.z +=  vSegPts[i][j].z;															} else {																tmppt = new Vector3D(atmp[k].x+vSegPts[i][j].x, atmp[k].y+vSegPts[i][j].y, atmp[k].z+vSegPts[i][j].z);							}														vPtsList.push(tmppt );														if(rescale && !_smoothScale){								tmppt.x *= lastscale.x;								tmppt.y *= lastscale.y;								tmppt.z *= lastscale.z;							}						}												if(_closePath && i == vSegPts.length-1 &&  j == vSegPts[i].length -1) 								break;												if(_closePath)							lastP = vPtsList;														vSegResults.push(vPtsList);						 					}				}				 				if(rescale && _smoothScale){					for (i = 0; i < vScales.length; ++i) {						 for (j = 0;j < vSegResults[i].length; ++j) {							vSegResults[i][j].x *= vScales[i].x;							vSegResults[i][j].y *= vScales[i].y;							vSegResults[i][j].z *= vScales[i].z;						 }					}					vScales = null;				}								if(rotate) rotation = null;				 				if(_closePath){					var stepx:Number;					var stepy:Number;					var stepz:Number;					var c:Vector.<Vector3D>;					var c2:Vector.<Vector.<Vector3D>> = new Vector.<Vector.<Vector3D>>();					 					for( i = 1; i < _subdivision+1; ++i){						c = new Vector.<Vector3D>();						for(j = 0; j < lastP.length; ++j){							stepx = (vSegResults[0][j].x - lastP[j].x)/_subdivision;							stepy = (vSegResults[0][j].y - lastP[j].y)/_subdivision;							stepz = (vSegResults[0][j].z - lastP[j].z)/_subdivision;							c.push( new Vector3D( lastP[j].x+(stepx*i) , lastP[j].y+(stepy*i), lastP[j].z+(stepz*i)) );						}						c2.push(c);					}										c2[0] = lastP;					generate(c2, (_coverAll)? vSegResults.length : 0, _coverAll);					c = null;					c2 = null;				}								generate(vSegResults, (_closePath && _coverAll)? 1 : 0, (_closePath && !_coverAll));								vSegPts = null;				_varr = null;								if(_MaterialsSubGeometries && _MaterialsSubGeometries.length>0){					var sglist:SubGeometryList;					var sg:SubGeometry;					for(i = 1;i<_MaterialsSubGeometries.length;++i){						sglist = _MaterialsSubGeometries[i];						sg = sglist.subGeometry;						if(sg && sglist.vertices.length >0){							this.geometry.addSubGeometry(sg);							this.subMeshes[this.subMeshes.length-1].material = sglist.material;							sg.updateVertexData(sglist.vertices);							sg.updateIndexData(sglist.indices);							sg.updateUVData(sglist.uvs);						}					}									} else {					_subGeometry.updateVertexData(_vertices);					_subGeometry.updateIndexData(_indices);					_subGeometry.updateUVData(_uvs);					this.geometry.addSubGeometry(_subGeometry);				}								if (_centerMesh)					MeshHelper.recenter( this);		}	}}class SubGeometryList {	import away3d.core.base.SubGeometry;	import away3d.materials.MaterialBase;		public var id:uint;	public var uvs:Vector.<Number>;	public var vertices:Vector.<Number>;	public var indices:Vector.<uint>;	public var subGeometry:SubGeometry;	public var material:MaterialBase;}