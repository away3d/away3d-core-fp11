package away3d.extrusions{	import away3d.core.base.data.UV;	import away3d.core.base.data.Vertex;	import away3d.core.base.Geometry;	import away3d.core.base.Object3D;	import away3d.core.base.SubGeometry;	import away3d.core.base.SubMesh;	import away3d.errors.AbstractMethodError;	import away3d.materials.MaterialBase;	import away3d.bounds.BoundingVolumeBase;	import away3d.entities.Mesh;	import away3d.tools.MeshHelper;	/*import away3d.tools.Weld;	import away3d.containers.ObjectContainer3D;*/	 	import flash.geom.Point;	import flash.geom.Vector3D;	  	/**	* Class for generating meshes with axial symmetry such as donuts, pipes, vases etc.	*/	public class LatheExtrude extends Mesh	{		private const EPS:Number = .0001;		private const LIMIT:uint = 64998;				private var _profile:Vector.<Vector3D>;		private var _axis:String;		private var _revolutions:Number;		private var _subdivision:uint;		private var _offsetRadius:Number;		private var _materials:Object;		private var _coverAll:Boolean;		private var _flip:Boolean;		private var _centerMesh:Boolean;		private var _thickness:Number;		private var _omit:String;		private var _tweek:Object;		private var varr:Vector.<Vertex>;		private var varr2:Vector.<Vertex>;		private var uvarr:Vector.<UV>;				private var _geomDirty : Boolean = true;		private var _subGeometry:SubGeometry; 		//private var _indice:uint;		private var _uva:UV;		private var _uvb:UV;		private var _uvc:UV;		private var _uvd:UV;		private var _va:Vertex;		private var _vb:Vertex;		private var _vc:Vertex;		private var _vd:Vertex;		private var _uvs : Vector.<Number>;		private var _vertices : Vector.<Number>;		private var _indices : Vector.<uint>;				public static const X_AXIS:String = "x";		public static const Y_AXIS:String = "y";		public static const Z_AXIS:String = "z";				/**		 *  Class LatheExtrude generates circular meshes such as donuts, pipes, pyramids etc.. from a series of Vector3D's		 *		 * KNOWN ISSUES AT THIS STAGE: 		 * - UV'S v value with thickness applied are offsetted		 * - Wrong uv's set for sides left right when revolutions value is lower or higher than 1		 * - Unsupported multiple materials		 * - Tweek object untested and subject to rewrite		 *		 *@param		material			[optional] MaterialBase. The LatheExtrude (Mesh) material. Optional in constructor, material must be set before LatheExtrude object is render.		 * @param		profile			[optional] Vector.<Vector3D>. A series of Vector3D's representing the profile information to be repeated/rotated around a given axis.		 * @param		axis				[optional] String. The axis to rotate around: X_AXIS, Y_AXIS or Z_AXIS. Default is LatheExtrude.Y_AXIS.		 * @param		revolutions		[optional] Number. The LatheExtrude object can have less than one revolution, like 0.6 for a piechart or greater than 1 if a tweek object is passed. Minimum is 0.01. Default is 1.		 * @param		subdivision		[optional] uint. Howmany segments will compose the mesh in its rotational construction. Minimum is 2. Default is 10.		 * @param		offsetRadius	[optional] Number. An offset radius if the profile data is not to be updated but the radius expected to be different. Default is 0.		 * @param		materials		[optional] Object. UNSUPPORTED AT THIS STAGE: will allow multiple material support when thickness is set higher to 1 Default is null.		 *	properties: bottom, top, left, right, front and back.		 * @param		coverall			[optional] Boolean. The way the uv mapping is spreaded across the shape. True covers an entire side of the geometry while false covers per segments. Default is true.		 * @param		flip:Boolean	[optional] Boolean. If the faces must be reversed depending on Vector3D's orientation. Default is false.		 * @param		centerMesh	[optional] Boolean. If the geometry needs to be recentered in its own object space. If the position after generation is set to 0,0,0, the object would be centered in worldspace. Default is false.		 * @param		thickness		[optional] Number. If the shape must simulate a thickness. Default is 0.		 * @param		omit				[optional] String.To prevent the generation of sides if thickness is set higher to 0. To avoid the bottom omit = "bottom", avoiding both top and bottom: omit = "bottom, top". Strings options: bottom, top, left, right, front and back. Default is "".		 * @param		tweek			[optional] Object. UNTESTED AT THIS STAGE. To build springs like shapes, rotation must be higher than 1. Properties of the tweek object are x,y,z, radius and rotation. Default is null.		 */		public function LatheExtrude(	material : MaterialBase = null, profile:Vector.<Vector3D> = null, axis:String = LatheExtrude.Y_AXIS , revolutions:Number = 1, subdivision:uint = 10, offsetRadius:Number = 0,									 				materials:Object = null, coverall:Boolean = true, flip:Boolean = false, centerMesh:Boolean = false, thickness:Number = 0, omit:String = "", tweek:Object = null)		{						var geom : Geometry = new Geometry();			_subGeometry = new SubGeometry();			geom.addSubGeometry(_subGeometry);			super(material, geom);			 			_profile = profile;			_axis = axis;			_revolutions = revolutions;			_subdivision = subdivision;			_offsetRadius = offsetRadius;			_materials = materials;			_coverAll = coverall;			_flip = flip;			_centerMesh = centerMesh;			_thickness = Math.abs(thickness);			_omit = omit;			_tweek = tweek;		}				/*    	* A Vector.<Vector3D> representing the profile information to be repeated/rotated around a given axis.    	*/		public function get profile():Vector.<Vector3D>    	{    		return _profile;    	}				public function set profile(val:Vector.<Vector3D>):void    	{			if (val.length > 1) {				_profile = val;				invalidateGeometry();			} else {				throw new Error("LatheExtrude error: the profile Vector.<Vector3D> must hold a mimimun of 2 vector3D's");			}    	}				/**    	 * Defines the axis used for the lathe rotation. Defaults to "y".    	 */		public function get axis():String    	{    		return _axis;    	}				public function set axis(val:String):void    	{    		if (_axis == val) return;			    		_axis = val;			invalidateGeometry();    	}				/**    	 * Defines the number of revolutions performed by the lathe extrusion. Defaults to 1.    	 */		public function get revolutions():Number    	{    		return _revolutions;    	}				public function set revolutions(val:Number):void    	{    		if (_revolutions == val) return;			_revolutions = (_revolutions>.001)? _revolutions : .001;    		_revolutions = val;			invalidateGeometry();    	}    			/**    	 * Defines the subdivisions created in the mesh for the total number of revolutions. Defaults to 2, minimum 2.    	 *     	 * @see #revolutions    	 */ 		public function get subdivision():uint		{			return _subdivision;		}				public function set subdivision(val:uint):void		{			val = (val<2)? 2 : val;			if (_subdivision == val) return;			_subdivision = val;			invalidateGeometry();		}				/**    	 * Defines an offset radius applied to the profile. Defaults to 0.    	 */		public function get offsetRadius():Number    	{    		return _offsetRadius;    	}				public function set offsetRadius(val:Number):void    	{    		if (_offsetRadius == val) return;			    		_offsetRadius = val;			invalidateGeometry();    	}    			/**		 * An optional object that defines left, right, front, back, top and bottom materials to be set on the resulting lathe extrusion.    	 */		public function get materials():Object    	{    		return _materials;    	}    			public function set materials(val:Object):void    	{    		_materials = val;			invalidateGeometry();    	}    			/**    	 * Defines if the texture(s) should be stretched to cover the entire mesh or per step between segments. Defaults to true.    	 */		public function get coverAll():Boolean		{			return _coverAll;		}				public function set coverAll(val:Boolean):void		{			if (_coverAll == val) return;						_coverAll = val;			invalidateGeometry();		}				/**    	 * Defines if the generated faces should be inversed. Default false.    	 */		public function get flip():Boolean		{			return _flip;		}				public function set flip(val:Boolean):void		{			if (_flip == val) return;						_flip = val;			invalidateGeometry();		}		    	    	/**    	 * Defines whether the mesh is recentered of not after generation    	 */    	public function get centerMesh():Boolean    	{    		return _centerMesh;    	}    	    	public function set centerMesh(val:Boolean):void    	{    		if (_centerMesh == val)    			return;    		    		_centerMesh = val;						if (_centerMesh && _subGeometry.vertexData.length > 0){				MeshHelper.applyPosition( this, (this.minX+this.maxX)*.5,  (this.minY+this.maxY)*.5, (this.minZ+this.maxZ)*.5);			}else{				invalidateGeometry();			}    	}		 		/**    	 * Defines the thickness of the resulting lathed geometry. Defaults to 0 (single face).    	 */		public function get thickness():Number    	{    		return _thickness;    	}				public function set thickness(val:Number):void    	{    		if (_thickness == val)				return;			    		_thickness = val;			invalidateGeometry();    	}    			/**		 * Defines if the top, bottom, left, right, front or back of the the extrusion is left open.    	 */		public function get omit():String    	{    		return _omit;    	}    			public function set omit(val:String):void    	{    		_omit = val;    		invalidateGeometry();    	}    			/**		 * Allows the building of shapes such as springs. Rotation must be higher than 1 to have significant effect. Properties of the objects are x,y,z,radius and rotation    	 */		public function get tweek():Object    	{    		return _tweek;    	}    			public function set tweek(val:Object):void    	{    		_tweek = val;    		invalidateGeometry();    	}		 		private function closeTopBottom(pointslength:int, matTop:*, matBottom:*, renderSide:Object):void		{			//add top and bottom			var va:Vertex;			var vb:Vertex;			var vc:Vertex;			var vd:Vertex;			var index:int = 0;						var i:uint;			var j:uint;			var a:Number;			var b:Number;			var total:uint = varr.length - pointslength;			var inc:uint = pointslength;			var profLength:uint = _profile.length-2;			for (i = 0; i < total; i+= inc) {				if (i!= 0) {										if (_coverAll) {						a = i/total;						b = (i+inc)/total;												_uva.u = 0;						_uva.v = a;						_uvb.u = 0;						_uvb.v = b;						_uvc.u = 1;						_uvc.v = b;						_uvd.u = 1;						_uvd.v = a;						 					} else {												_uva.u = 0;//downleft						_uva.v = 0;						_uvb.u = 0;//topleft						_uvb.v = 1;						_uvc.u = 1;//topright						_uvc.v = 1;						_uvd.u = 1;//downright						_uvd.v = 0;					}										if (renderSide["top"]) {						 						if (_revolutions == 1 && i + inc == total && _tweek == null) {														va = varr[i];							vb = varr[inc];														vc = varr2[inc];							vd =  varr2[i];						} else {							va = varr[i];							vb = varr[i+inc];							vc = varr2[i+inc];							vd =  varr2[i];						}						 						if (_flip) {							addFace(vb, va, vc, matTop, _uvb, _uva, _uvc );							addFace(vc, va, vd, matTop, _uvc, _uva, _uvd );						} else {							addFace(va, vb, vc, matTop, _uva, _uvb, _uvc );							addFace(va, vc, vd, matTop, _uva, _uvc, _uvd );						}					}										if (renderSide["bottom"]) {						j = i+profLength;						 						if (_revolutions == 1 && i + inc == total && _tweek == null) {							va = varr[j];							vb = varr[profLength];							vc = varr2[profLength];							vd =  varr2[j];						} else {							va = varr[j];							vb = varr[j+inc];							vc = varr2[j+inc];							vd =  varr2[j];						}						 						if (_flip) {							addFace(va, vb, vc, matBottom, _uva, _uvb, _uvc );							addFace(va, vc, vd, matBottom, _uva, _uvc, _uvd );						} else {							addFace(vb, va, vc, matBottom, _uvb, _uva, _uvc );							addFace(vc, va, vd, matBottom, _uvc, _uva, _uvd );						}					}				}								index += pointslength;			}		}				private function closeSides(pointcount:int, matRight:*, matLeft:*, renderSide:Object):void		{			var va:Vertex;			var vb:Vertex;			var vc:Vertex;			var vd:Vertex;			var offset:uint = varr.length - pointcount;			var i:uint;			var j:uint;			var a:Number;			var b:Number;						var iter:int = pointcount-1;			var step:Number = 1/iter;						for (i = 0; i<iter; ++i) {				if (_coverAll) {					a = i/iter;					b = a+step;										_uva.u = 0;					_uva.v = a;					_uvb.u = 0;					_uvb.v = b;					_uvc.u = 1;					_uvc.v = b;					_uvd.u = 1;					_uvd.v = a;						 				} else {										_uva.u = 0;//downleft					_uva.v = 0;					_uvb.u = 0;//topleft					_uvb.v = 1;					_uvc.u = 1;//topright					_uvc.v = 1;					_uvd.u = 1;//downright					_uvd.v = 0; 				}								if (renderSide["left"]) {					va = varr[i+1];					vb = varr[i];					vc = varr2[i];					vd = varr2[i+1];					if (_flip) {						addFace(vb, va, vc, matLeft, _uvb, _uva, _uvc );						addFace(vc, va, vd, matLeft, _uvc, _uva, _uvd );					} else {						addFace(va, vb, vc, matLeft, _uva, _uvb, _uvc );						addFace(va, vc, vd, matLeft, _uva, _uvc, _uvd );					}				}								if (renderSide["right"]) {					j = offset+i;					va = varr[j + 1];					vb = varr[j ];					vc = varr2[j];					vd = varr2[j + 1];					if (_flip) {						addFace(va, vb, vc, matRight, _uva, _uvb, _uvc );						addFace(va, vc, vd, matRight, _uva, _uvc, _uvd );					} else {						addFace(vb, va, vc, matRight, _uvb, _uva, _uvc );						addFace(vc, va, vd, matRight, _uvc, _uva, _uvd );					}				}							}		}		private function generate(vectors:Vector.<Vector3D>, axis:String, tweek:Object, inside:Boolean = false, mat:MaterialBase = null, render:Boolean = true):void		{			if (!tweek)				tweek = {};			 			if (isNaN(tweek["x"]) || !tweek["x"]) tweek["x"] = 0;			if (isNaN(tweek["y"]) || !tweek["y"]) tweek["y"] = 0;			if (isNaN(tweek["z"]) || !tweek["z"]) tweek["z"] = 0;			if (isNaN(tweek["radius"]) || !tweek["radius"]) tweek["radius"] = 0;			 			var angle:Number = 0;			var step:Number = 360 / _subdivision;			 			var j:uint;						var tweekX:Number = 0;			var tweekY:Number = 0;			var tweekZ:Number = 0;			var tweekradius:Number = 0;			var tweekrotation:Number = 0;						var tmpVecs:Vector.<Vector3D>;			var aRads:Array = [];									var uvu:Number;			var uvv:Number;						if(!varr) varr = new Vector.<Vertex>();						for (var i:uint = 0; i < vectors.length; ++i) {				varr.push(new Vertex(vectors[i].x, vectors[i].y, vectors[i].z) ); 				uvarr.push(new UV(0,1%i)); 			}			  			//Vertex generation			var offsetradius:Number = -_offsetRadius;			var factor:Number = 0;			var stepm:Number = 360*_revolutions;						for (i = 0; i <= _subdivision * _revolutions ; ++i) {								tmpVecs = new Vector.<Vector3D>();				tmpVecs = vectors.concat();								for(j = 0;j<tmpVecs.length;++j){										factor = ((_revolutions-1)/(varr.length+1));									if(tweek[X_AXIS] != 0)						tweekX += (tweek[X_AXIS] * factor)/_revolutions;											if(tweek[Y_AXIS] != 0)						tweekY += (tweek[Y_AXIS] * factor)/_revolutions;											if(tweek[Z_AXIS] != 0)						tweekZ += (tweek[Z_AXIS] * factor)/_revolutions;											if(tweek["radius"] != 0)						tweekradius += (tweek["radius"]/(varr.length+1));											if(tweek["rotation"] != 0)						tweekrotation +=  360/(tweek["rotation"]*_subdivision);						 					if (_axis == X_AXIS) {							if(i==0) aRads[j] = offsetradius-Math.abs(tmpVecs[j].z);							 							tmpVecs[j].z = Math.cos(-angle/180*Math.PI) * (aRads[j] + tweekradius );							tmpVecs[j].y = Math.sin(angle/180*Math.PI) * (aRads[j] + tweekradius );														if(i == 0){								varr[j].z += tmpVecs[j].z;								varr[j].y += tmpVecs[j].y;							}							 					} else if (_axis == Y_AXIS) {													if(i==0) aRads[j] = offsetradius-Math.abs(tmpVecs[j].x);							 							tmpVecs[j].x = Math.cos(-angle/180*Math.PI) *  (aRads[j] + tweekradius );							tmpVecs[j].z = Math.sin(angle/180*Math.PI) * (aRads[j] + tweekradius );							 							if(i == 0){								varr[j].x = tmpVecs[j].x;								varr[j].z = tmpVecs[j].z;							}							 					} else {													if(i==0) aRads[j] = offsetradius-Math.abs(tmpVecs[j].y);							 							tmpVecs[j].x = Math.cos(-angle/180*Math.PI) * (aRads[j] + tweekradius );							tmpVecs[j].y = Math.sin(angle/180*Math.PI) * (aRads[j] + tweekradius );														if(i == 0){								varr[j].x = tmpVecs[j].x;								varr[j].y = tmpVecs[j].y;							}					}										tmpVecs[j].x += tweekX;					tmpVecs[j].y += tweekY;					tmpVecs[j].z += tweekZ;										varr.push(new Vertex(tmpVecs[j].x, tmpVecs[j].y, tmpVecs[j].z) );										if(_coverAll) {						uvu = angle/stepm;					} else {						uvu = (i%2 == 0)? 0 : 1;					}					 					uvv = j/(_profile.length-1);					 					/*if(i == 0)						trace(uvv);*/											uvarr.push(new UV(uvu, uvv));				 }				 				angle += step;							}						if (render) {				var index:uint;				var inc:uint = vectors.length;				var loop:uint = varr.length - vectors.length;				var va:Vertex;				var vb:Vertex;				var vc:Vertex;				var vd:Vertex;				var uva:UV;				var uvb:UV;				var uvc:UV;				var uvd:UV;				var uvind:uint;				var vind:uint;				var iter:int = inc-1;								/*if(_thickness>0){					var step:Number = 1/inc-1 ;					var a:Number;					var b:Number;				}*/												for (i = 0; i < loop; i += inc) {					index = 0;					for (j = 0; j < iter; ++j) {						if (i>0) {							uvind = i + index;							vind = uvind;														uva = uvarr[uvind + 1];							uvb = uvarr[uvind];							uvc = uvarr[uvind + inc];							uvd = uvarr[uvind + inc + 1];							/*							if(_thickness>0){								a = j/(inc);																b = a+step;								if(i == 0 && index <inc){									trace("a: "+a);									trace("b: "+b);								}								uva.v = a;								uvb.v = b;								uvc.v = b;								uvd.v = a;							}*/							 							if (_revolutions == 1 && i + inc == loop && _tweek == null) {								va = varr[vind + 1];								vb = varr[vind];								vc = varr[index + inc];								vd = varr[index + inc + 1];							} else {								va = varr[vind + 1];								vb = varr[vind];								vc = varr[vind + inc];								vd = varr[vind + inc + 1];							}							 							if (_flip) {								if (inside) {									_uva.u = 1-uva.u;									_uva.v = uva.v;									_uvb.u = 1-uvb.u;									_uvb.v = uvb.v;									_uvc.u = 1-uvc.u;									_uvc.v = uvc.v;									_uvd.u = 1-uvd.u;									_uvd.v = uvd.v;																		addFace(va, vb, vc, mat, _uva, _uvb, _uvc);									addFace(va, vc, vd, mat, _uva, _uvc, _uvd);																	} else {																		addFace(vb, va, vc, mat, uvb, uva, uvc );									addFace(vc, va, vd, mat, uvc, uva, uvd );								}															} else {																if (inside) {									_uva.u = 1-uva.u;									_uva.v = uva.v;									_uvb.u = 1-uvb.u;									_uvb.v = uvb.v;									_uvc.u = 1-uvc.u;									_uvc.v = uvc.v;									_uvd.u = 1-uvd.u;									_uvd.v = uvd.v;																		addFace(vb, va, vc, mat, _uvb, _uva, _uvc);									addFace(vc, va, vd, mat, _uvc, _uva, _uvd);																	} else {																		addFace(va, vb, vc, mat, uva, uvb, uvc );									addFace(va, vc, vd, mat, uva, uvc, uvd );								}															}						}												index++;					}				}			}		}				private function buildThicknessPoints(vectors:Vector.<Vector3D>, thickness:Number, prop1:String, prop2:String):Vector.<FourPoints>		{			var anchors:Vector.<FourPoints> = new Vector.<FourPoints>();			var lines:Vector.<FourPoints> = new Vector.<FourPoints>();			var i:uint;			var totallength:uint;						for( i = 0;i<vectors.length-1;++i){				if(vectors[i][prop1] == 0 && vectors[i][prop2] == 0){					vectors[i][prop1] = EPS;				}				if(vectors[i+1][prop2] != null && vectors[i][prop2] == vectors[i+1][prop2]){					vectors[i+1][prop2] += EPS;				}				if(vectors[i][prop1] != null && vectors[i][prop1]  == vectors[i+1][prop1]){					vectors[i+1][prop1] += EPS;				}				anchors.push(defineAnchors(vectors[i], vectors[i+1], thickness, prop1, prop2 ));				totallength++;			}			 			var oPointResult:FourPoints;						if(totallength>1){				for(i = 0;i<totallength;++i){										if(i < totallength-1){						oPointResult = defineLines(i, lines, anchors[i], anchors[i+1]);					} else{						oPointResult = defineLines(i, lines, anchors[i], anchors[i-1]);					}										if(oPointResult != null) lines.push(oPointResult);				}							} else{								var fourPoints:FourPoints = new FourPoints();				var anchorFP:FourPoints = anchors[0];				fourPoints.pt1 = anchorFP.pt1;				fourPoints.pt2 = anchorFP.pt2;				fourPoints.pt3 = anchorFP.pt3;				fourPoints.pt4 = anchorFP.pt4;				lines.push(fourPoints);			} 			return  lines;		}				private function defineLines(index:int, Lines:Vector.<FourPoints>, point1:FourPoints, point2:FourPoints = null):FourPoints		{			var fourPoints:FourPoints = new FourPoints();						if(point2 == null){				var tmppt:FourPoints = Lines[index -1];				fourPoints.pt1 = tmppt.pt3;				fourPoints.pt2 = tmppt.pt4;				fourPoints.pt3 = point1.pt3;				fourPoints.pt4 = point1.pt4			}			 			var line1:Line = buildObjectLine(point1.pt1.x, point1.pt1.y, point1.pt3.x, point1.pt3.y);			var line2:Line = buildObjectLine(point1.pt2.x, point1.pt2.y, point1.pt4.x, point1.pt4.y);			var line3:Line = buildObjectLine(point2.pt1.x, point2.pt1.y, point2.pt3.x, point2.pt3.y);			var line4:Line = buildObjectLine(point2.pt2.x, point2.pt2.y, point2.pt4.x, point2.pt4.y);						var cross1:Point = lineIntersect (line3, line1);			var cross2:Point = lineIntersect (line2, line4);					if(cross1 != null && cross2 != null){								if(index == 0){					fourPoints.pt1 = point1.pt1;					fourPoints.pt2 = point1.pt2;					fourPoints.pt3 = cross1;					fourPoints.pt4 = cross2; 										return fourPoints;				}								fourPoints.pt1 = point1.pt3;				fourPoints.pt2 = point1.pt4;				fourPoints.pt3 = cross1;				fourPoints.pt4 = cross2;								return fourPoints;							} else {				return null;			} 		}				private function defineAnchors(base:Vector3D, baseEnd:Vector3D, thickness:Number, prop1:String, prop2:String):FourPoints		{			var angle:Number = (Math.atan2(base[prop2] - baseEnd[prop2], base[prop1] - baseEnd[prop1])* 180)/ Math.PI;			angle -= 270;			var angle2:Number = angle+180;						var fourPoints:FourPoints = new FourPoints();			fourPoints.pt1 = new Point(base[prop1], base[prop2]);			fourPoints.pt2 = new Point(base[prop1], base[prop2]);			fourPoints.pt3 = new Point(baseEnd[prop1], baseEnd[prop2]);			fourPoints.pt4 = new Point(baseEnd[prop1], baseEnd[prop2]);						var radius:Number = thickness*.5;						fourPoints.pt1.x = fourPoints.pt1.x+Math.cos(-angle/180*Math.PI)*radius;			fourPoints.pt1.y = fourPoints.pt1.y+Math.sin(angle/180*Math.PI)*radius;						fourPoints.pt2.x = fourPoints.pt2.x+Math.cos(-angle2/180*Math.PI)*radius;			fourPoints.pt2.y = fourPoints.pt2.y+Math.sin(angle2/180*Math.PI)*radius;						fourPoints.pt3.x = fourPoints.pt3.x+Math.cos(-angle/180*Math.PI)*radius;			fourPoints.pt3.y = fourPoints.pt3.y+Math.sin(angle/180*Math.PI)*radius;						fourPoints.pt4.x = fourPoints.pt4.x+Math.cos(-angle2/180*Math.PI)*radius;			fourPoints.pt4.y = fourPoints.pt4.y+Math.sin(angle2/180*Math.PI)*radius;			 			return fourPoints;		}				private function buildObjectLine(origX:Number, origY:Number, endX:Number, endY:Number):Line		{  			var line:Line = new Line();			line.ax = origX;			line.ay = origY;			line.bx = endX - origX;			line.by = endY - origY;						return line;		}				private function lineIntersect (Line1:Line, Line2:Line):Point		{			Line1["bx"] = (Line1["bx"] == 0)? EPS : Line1["bx"];			Line2["bx"] = (Line2["bx"] == 0)? EPS : Line2["bx"];						var a1:Number = Line1["by"] / Line1["bx"];			var b1:Number = Line1["ay"] - a1 * Line1["ax"];			var a2:Number = Line2["by"] / Line2["bx"];			var b2:Number = Line2["ay"] - a2 * Line2["ax"];			var nzero:Number =  ((a1 - a2) == 0)? EPS : a1 - a2;			var ptx:Number = ( b2 - b1 )/(nzero);			var pty:Number = a1 * ptx + b1;						if(isFinite(ptx) && isFinite(pty)){				return new Point(ptx, pty);			} else {				trace("infinity");				return null;			}		}		     	private function buildExtrude():void    	{			initHolders();			_geomDirty = false;			 			//_tweek = (_tweek == null)? {x:0, y:0, z:0, radius:0, rotation:0} : _tweek;			if (_profile.length > 1) {				var prop1:String;				var prop2:String;				var prop3:String;									switch (_axis) {					case "x" :						prop1 = "x";						prop2 = "z";						prop3 = "y";						break;						case "y" :						prop1 = "y";						prop2 = "x";						prop3 = "z";						break;						case "z" :						prop1 = "z";						prop2 = "y";						prop3 = "x";				}									if (_thickness != 0) {						var Lines:Vector.<FourPoints> = buildThicknessPoints(_profile, thickness, prop1, prop2);					var i:uint;										var aListsides:Array = ["top","bottom", "right", "left", "front", "back"];					var renderSide:RenderSide = new RenderSide();					for(i = 0;i<aListsides.length;++i){						renderSide[aListsides[i]] = (_omit.indexOf(aListsides[i]) == -1);					}										var oPoints:FourPoints;					var vector:Vector3D;					var vector2:Vector3D;					var vector3:Vector3D;					var vector4:Vector3D;					var aPointlist1:Vector.<Vector3D> = new Vector.<Vector3D>();					var aPointlist2:Vector.<Vector3D> = new Vector.<Vector3D>();										for(i = 0;i<Lines.length;++i){												oPoints = Lines[i];						vector = new Vector3D();						vector2 = new Vector3D();						 						if(i == 0){														vector[prop1] = oPoints.pt2.x;							vector[prop2] = oPoints.pt2.y;							vector[prop3] = _profile[0][prop3];							aPointlist1.push(vector);														vector2[prop1] = oPoints.pt1.x;							vector2[prop2] = oPoints.pt1.y;							vector2[prop3] = _profile[0][prop3];							aPointlist2.push(vector2);							 							if(Lines.length == 1) {								vector3 = new Vector3D();								vector4 = new Vector3D();																vector3[prop1] = oPoints.pt4.x;								vector3[prop2] = oPoints.pt4.y;								vector3[prop3] = _profile[0][prop3];								aPointlist1.push(vector3);																vector4[prop1] = oPoints.pt3.x;								vector4[prop2] = oPoints.pt3.y;								vector4[prop3] = _profile[0][prop3];														aPointlist2.push(vector4);								 							} 							 						} else if (i == Lines.length-1) {							 							vector[prop1] = oPoints.pt2.x;							vector[prop2] = oPoints.pt2.y;							vector[prop3] = _profile[i][prop3];							aPointlist1.push(vector);														vector2[prop1] = oPoints.pt1.x;							vector2[prop2] = oPoints.pt1.y;							vector2[prop3] = _profile[i][prop3];							aPointlist2.push(vector2);							 							vector3 = new Vector3D();							vector4 = new Vector3D();														vector3[prop1] = oPoints.pt4.x;							vector3[prop2] = oPoints.pt4.y;							vector3[prop3] = _profile[i][prop3];							aPointlist1.push(vector3);														vector4[prop1] = oPoints.pt3.x;							vector4[prop2] = oPoints.pt3.y;							vector4[prop3] = _profile[i][prop3];							aPointlist2.push(vector4);													} else {							 							vector[prop1] = oPoints.pt2.x;							vector[prop2] = oPoints.pt2.y;							vector[prop3] = _profile[i][prop3];							aPointlist1.push(vector);														vector2[prop1] = oPoints.pt1.x;							vector2[prop2] = oPoints.pt1.y;							vector2[prop3] = _profile[i][prop3];													aPointlist2.push(vector2);						}											}										var mf:MaterialBase;					var mb:MaterialBase;					var mt:MaterialBase;					var mbo:MaterialBase;					var mr:MaterialBase;					var ml:MaterialBase;										if(_materials != null){						mf = (_materials["front"] != null)? _materials["front"] : null;						mb = (_materials["back"] != null)? _materials["back"] : null;						mt = (_materials["top"] != null)? _materials["top"] : null;						mbo = (_materials["bottom"] != null)? _materials["bottom"] : null;						mr = (_materials["right"] != null)? _materials["right"] : null;						ml = (_materials["left"] != null)? _materials["left"] : null;					}											varr = new Vector.<Vertex>();					generate(aPointlist1, _axis, _tweek, false, mf, renderSide["front"]);					varr2 = new Vector.<Vertex>();					varr2 = varr2.concat(varr);					varr = new Vector.<Vertex>();					generate(aPointlist2, _axis, _tweek, true, mb, renderSide["back"]);							closeTopBottom(_profile.length, mt, mbo, renderSide);										if (_revolutions != 1)						closeSides(_profile.length, mr, ml, renderSide);							} else {					generate(_profile, _axis, _tweek);				}							} else {				throw new Error("LatheExtrude error: the profile Vector.<Vector3D> must hold a mimimun of 2 vector3D's");			}						_subGeometry.updateVertexData(_vertices);			_subGeometry.updateIndexData(_indices);			_subGeometry.updateUVData(_uvs);							varr = varr2 = null;			uvarr = null;						//Weld.apply(ObjectContainer3D(this));						if (_centerMesh)				MeshHelper.recenter( this);		}				private function addFace(v0:Vertex, v1:Vertex, v2:Vertex, mat:MaterialBase, uv0:UV, uv1:UV, uv2:UV ):void		{			if(_vertices.length+9>LIMIT){				_subGeometry.updateVertexData(_vertices);				_subGeometry.updateIndexData(_indices);				_subGeometry.updateUVData(_uvs);								_subGeometry = new SubGeometry();				this.geometry.addSubGeometry(_subGeometry);				_uvs = new Vector.<Number>();				_vertices = new Vector.<Number>();				_indices = new Vector.<uint>();				 			}						var uvind:uint;			var bv0:Boolean;			var bv1:Boolean;			var bv2:Boolean;			var vlength:uint = _vertices.length;			var ind0:uint;			var ind1:uint;			var ind2:uint;			for(var i:uint = 0; i<vlength ;i+=3){				uvind = (i/3)*2;								if(!bv0 && _vertices[i] == v0.x){					if(_vertices[i+1] == v0.y && _vertices[i+2] == v0.z){						if(_uvs[uvind] == uv0.u && _uvs[uvind+1] == uv0.v ){							ind0 = i/3;							bv0 = true;							continue;						}					}				}								if(!bv1 && _vertices[i] == v1.x){					if(_vertices[i+1] == v1.y && _vertices[i+2] == v1.z){						if(_uvs[uvind] == uv1.u && _uvs[uvind+1] == uv1.v ){							ind1 = i/3;							bv1 = true;							continue;						}					}				}								if(!bv2 && _vertices[i] == v2.x){					if(_vertices[i+1] == v2.y && _vertices[i+2] == v2.z){						if(_uvs[uvind] == uv2.u && _uvs[uvind+1] == uv2.v ){							ind2 = i/3;							bv2 = true;						}					}				}								if(bv0 && bv1 && bv2)					break;			}						if(!bv0){				ind0 = _vertices.length/3;				_vertices.push(v0.x, v0.y, v0.z);				_uvs.push(uv0.u, uv0.v);			}			if(!bv1){				ind1 = _vertices.length/3;				_vertices.push(v1.x, v1.y, v1.z);				_uvs.push(uv1.u, uv1.v);			}			if(!bv2){				ind2 = _vertices.length/3;				_vertices.push(v2.x, v2.y, v2.z);				_uvs.push(uv2.u, uv2.v);			}						_indices.push(ind0, ind1, ind2);					}				private function initHolders():void		{				uvarr = new Vector.<UV>();			//_indice = 0;			_uva = new UV(0,0);			_uvb = new UV(0,0);			_uvc = new UV(0,0);			_uvd = new UV(0,0);			_va = new Vertex(0,0,0);			_vb = new Vertex(0,0,0);			_vc = new Vertex(0,0,0);			_vd = new Vertex(0,0,0);			_uvs = new Vector.<Number>();			_vertices = new Vector.<Number>();			_indices = new Vector.<uint>();						_subGeometry.autoDeriveVertexNormals = true;            _subGeometry.autoDeriveVertexTangents = true;		}		 		/**		 * @inheritDoc		 */		override public function get bounds() : BoundingVolumeBase		{			if (_geomDirty) 				buildExtrude();						return super.bounds;		}		/**		 * @inheritDoc		 */		override public function get geometry() : Geometry		{			if (_geomDirty) buildExtrude();			 			return super.geometry;		}		/**		 * @inheritDoc		 */		override public function get subMeshes():Vector.<SubMesh>		{			if (_geomDirty) buildExtrude();			 			return super.subMeshes;		} 		/**		 * Invalidates the geometry, causing it to be rebuillded when requested.		 */		private function invalidateGeometry() : void		{			_geomDirty = true;			invalidateBounds();		}   	}}class Line {	public var ax:Number;	public var ay:Number;	public var bx:Number;	public var by:Number;}class RenderSide {	public var top:Boolean;	public var bottom:Boolean;	public var right:Boolean;	public var left:Boolean;	public var front:Boolean;	public var back:Boolean;}class FourPoints {	import flash.geom.Point;		public var pt1:Point;	public var pt2:Point;	public var pt3:Point;	public var pt4:Point;} 