package away3d.loading{	import away3d.events.LoaderEvent;	import away3d.events.ResourceEvent;	import flash.events.EventDispatcher;	import flash.net.URLRequest;	/**	 * ResourceLoadSession handles loading and parsing of a file and (optionally) all of its dependencies.	 */    internal class ResourceLoadSession extends EventDispatcher    {        private var _dependencyStack : Vector.<Vector.<ResourceDependency>>;        private var _dependencyIndexStack : Vector.<uint>;        private var _currentDependencyIndex : uint;        private var _currentDependencies : Vector.<ResourceDependency>;        private var _uri : String;		private var _lastUri : String;        private var _resource : IResource;        private var _ignoreDependencies : Boolean;        private var _loadingDependency : ResourceDependency;		private var _handle : IResource;		/**		 * Create a new ResourceLoadSession object.		 */        public function ResourceLoadSession()        {            _dependencyStack = new Vector.<Vector.<ResourceDependency>>();            _dependencyIndexStack = new Vector.<uint>();        }		/**		 * Loads a file and (optionally) all of its dependencies.		 * @param url The url of the main file to be loaded.		 * @param ignoreDependencies Indicates whether or not dependencies should be ignored or loaded.		 * @param parser An optional parser object that will translate the loaded data into a usable resource.		 */        public function load(url : String, ignoreDependencies : Boolean = false, parser : Class = null) : void        {            _uri = url.replace(/\\/g, "/");            _ignoreDependencies = ignoreDependencies;            _currentDependencies = new Vector.<ResourceDependency>();            _currentDependencies.push(new ResourceDependency(url, url, null, null));			retrieveNext(parser);        }		/**		 * Loads a resource from already loaded data.		 * @param data The data to be parsed. Depending on the parser type, this can be a ByteArray, String or XML.		 * @param id The id of the object to be loaded, used for resource management.		 * @param ignoreDependencies Indicates whether or not dependencies should be ignored or loaded.		 * @param parser An optional parser object that will translate the data into a usable resource.		 */		public function parse(data : *, id : String, ignoreDependencies : Boolean, parser : Class) : void		{			_uri = id;            _ignoreDependencies = ignoreDependencies;            _currentDependencies = new Vector.<ResourceDependency>();            _currentDependencies.push(new ResourceDependency(id, null, data, null));			retrieveNext(parser);		}				/**		 * The url or id of the loaded and parsed object.		 */        public function get uri() : String        {            return _uri;        }		/**		 * The object that will contain all the loaded and parsed data.		 */		public function get handle() : IResource		{			return _handle;		}		/**		 * Recursively retrieves the next to-be-loaded and parsed dependency on the stack, or pops the list off the		 * stack when complete and continues on the top set.		 * @param parser The parser that will translate the data into a usable resource.		 */        private function retrieveNext(parser : Class = null) : void        {            // move back up the stack while we're at the end            while (_currentDependencies && _currentDependencyIndex == _currentDependencies.length) {                if (_dependencyStack.length > 0) {                    _currentDependencies = _dependencyStack.pop();                    _currentDependencyIndex = _dependencyIndexStack.pop();                }                else _currentDependencies = null;            }            if (_currentDependencies && _currentDependencyIndex<_currentDependencies.length) {                retrieveDependency(_currentDependencies[_currentDependencyIndex], parser);                _currentDependencyIndex++;            } else {                dispatchEvent(new ResourceEvent(ResourceEvent.RESOURCE_RETRIEVED, _resource, _uri));            }        }		/**		 * Retrieves a single dependency.		 * @param parser The parser that will translate the data into a usable resource.		 */        private function retrieveDependency(dependency : ResourceDependency, parser : Class = null) : void        {            var loader : AssetLoader = new AssetLoader();            loader.addEventListener(LoaderEvent.LOAD_COMPLETE, onRetrievalComplete);			loader.addEventListener(LoaderEvent.LOAD_ERROR, onRetrievalFailed);            _loadingDependency = dependency;			if (_loadingDependency.data) {				loader.parseData(_loadingDependency.data, _loadingDependency.id, parser);			}			else {				_lastUri = dependency.url;				loader.load(new URLRequest(_lastUri), parser);			}			_handle ||= loader.handle;			try{				_loadingDependency.resource = loader.handle;			} catch(e:Error){				//failure load resource			}        }				/**		 * Called when a single dependency loading failed, and pushes further dependencies onto the stack.		 * @param event		 */		private function onRetrievalFailed(event : LoaderEvent) : void        {            var loader : AssetLoader = AssetLoader(event.target);            loader.removeEventListener(LoaderEvent.PARSE_COMPLETE, onRetrievalComplete);						if(hasEventListener(LoaderEvent.LOAD_ERROR)){				dispatchEvent(new LoaderEvent(LoaderEvent.LOAD_ERROR, event.resource, _lastUri, event.message));			} else{				trace("Unable to load "+_lastUri);			}						var ext:String = _lastUri.substring(_lastUri.length-4, _lastUri.length).toLowerCase();			if(ext == ".mtl" || ext ==".jpg" || ext ==".png"){				if (!_resource) _resource = event.resource;				_loadingDependency.resolveFailure();				prepareNextRetreive(loader, event, false);			}		}		 		/**		 * Called when a single dependency was parsed, and pushes further dependencies onto the stack.		 * @param event		 */        private function onRetrievalComplete(event : LoaderEvent) : void        {            var loader : AssetLoader = AssetLoader(event.target);            loader.removeEventListener(LoaderEvent.PARSE_COMPLETE, onRetrievalComplete);			loader.removeEventListener(LoaderEvent.LOAD_ERROR, onRetrievalFailed);						prepareNextRetreive(loader, event);        }				/**		 * Pushes further dependencies onto the stack.		 * @param event		 */		private function prepareNextRetreive(loader:AssetLoader, event : LoaderEvent, resolve:Boolean = true) : void        {			dispatchEvent(new ResourceEvent(ResourceEvent.DEPENDENCY_RETRIEVED, event.resource, event.url));            if (!_resource) _resource = event.resource;						if(resolve) _loadingDependency.resolve();            if (_ignoreDependencies){				dispatchEvent(new ResourceEvent(ResourceEvent.RESOURCE_RETRIEVED, _resource, _uri));			} else{				_dependencyStack.push(_currentDependencies);				_dependencyIndexStack.push(_currentDependencyIndex);				_currentDependencyIndex = 0;				_currentDependencies = loader.dependencies;				retrieveNext();			}					}	}}